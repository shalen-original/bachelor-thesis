## Further thoughts on professor Nabil's approach
I have been pondering on this idea and I tought on a simple "protocol" than would enable *some* level of confidence on the fact that what is agreed on the blockchain is respected. This is still not a complete solution, as explained below.

In this protocol, both the publisher and the farmer generate a public-private key pair for each computation and both communicate the public key that they will use to the blockchain during the initial agreement phase. In this wat, they both commit to using that key pair for this exchange. Additionally, the publisher will communicate to the blockchain the hash of the seed of a pseudo-random number generator (which implementation is known by all parties). 

When the access period begins, the publisher will initialise the PRNG with the seed previously decided. Periodically during the access period, the publisher will generate the next number in the sequence and encrypt it with his private key: in this way, we are sure that the message comes from the publisher. Then, the encrypted message will be forwared to the farmer, which will encrypt it with his private key. At this point, a copy of the doubly-signed message will be kept by the farmer and another copy will be returned to the publisher. Every doubly-signed message is a verifiable token that says that, up to timestamp N, everything is going fine. If for any reason, at some point the publisher detects that something is not as agreed, it can stop publishing tokens and can terminate the session: the tokens will be used to determine how much the farmer should be payed (if at all). A farmer can kick out a publisher that does not regularly provide these tokens. In case of dispute, the publisher can provide the seed used (which hash is publicly available on the blockchain, so the publisher cannot lie) and the stash of double-signed tokens held by the publisher and by the farmer can be checked to see what happened.

This is only a rough description of the protocol, but already some problems can be highlighted. Mainly:

* The protocol does not guarantee the correctness of any computation, only that up to timestamp N both the publisher and the farmer agree that everything seems to go as planned
* There is no "safe" way for the publisher to know that everything is going well. The farmer could lie at any point about the status of the docker containers. Therefore, the publisher may be convinced that everything is going as planned and continue to send signed messages even if the actual situation is not as agreed upon. #fundamentalflaw

## Verifiable computing to the rescue
The proper solution to our problem seems to go by the name of verifiable computing. I have been reading about this and, while I found [some](related-material/computationally-sound-proofs-Micali.pdf) [papers](related-material/delegating-computation-interactive-proofs-for-muggles-goldwasser-et-al.pdf) rather difficult to follow, a short summary in the form of a [blog post](https://mybiasedcoin.blogspot.it/2013/09/guest-post-by-justin-thaler-mini-survey.html) and [this paper](related-material/verifying-computation-without-reexecuting-them-Walfish.pdf) helped me to understand the current situation of this field.

However, theoretical results and practical ones do not always match. The algorithms proposed in some of the papers would require about twenty order of magnitudes more computation in order to produce a proof with respect to simply execute the computation: this is interesting from a theoretical perspective but is way too much for practical applications. Enter [Pequin](https://github.com/pepper-project/pequin), based on its more complicated brother [Pepper](https://github.com/pepper-project/pepper). The details of the project are available [here](https://www.pepper-project.org/). Even if the Github repository seems a bit quiescent, the project states that they have reached intersting results, moving from the twenty order of magnitudes mentioned above to three-six. While this overhead is still too much for real world application, I think it could be an interesting proof of concept for my thesis.

If we agree on using this project, then a simple variation of the diagrams I already propose would allow the integration of the checking of the proof, instead of relying on the publisher's acceptance of the result. I am investigating.

Meanwhile, I am working on having a working sample implementation which involves the three main part of the application (smart contracts, farmer orchestrator and publisher interface) communicating among themselves.


