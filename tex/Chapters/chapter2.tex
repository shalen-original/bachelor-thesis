%!TEX root = ../thesis.tex

\section{State of the art}
\label{sect:state-of-the-art}

\subsection{Verifiable computing}
Using current blockchain technology, building a fully decentralized market is possible without excessive engineering effort: the difficult part is ensuring that what the parties agree on on the blockchain is actually respected in the real world. In particular, in our case, the publisher of the computation does not trust who performs the computation: therefore, even if on chain they agree on the fact that a certain computation should be executed, the publisher cannot be sure that the results submitted are actually those generated by running the requested computation.

While researching a solution to this problem, we found that there exists an entire field of computer science known as \emph{Verifiable Computing}, which investigates and addresses exactly this problem. In this field, the problem is usually described as involving two parties, a prover and a verifier. The verifier asks the prover to perform a computation, the prover executes it and then tries to show to the verifier:

\begin{enumerate}
    \item that the executed computation was actually the one requested and
    \item that the executed computation was executed correctly.
\end{enumerate}

Of course, the verifier should be able to check the correctness of this proofs in a time that is substantially less than the one required to perform the computation by himself.

There has been a lot of research on the theoretical aspects of this problem, which led to some remarkable results. In particular, for every language $L \in NP$, a \emph{Probabilistically Checkable Proof} (PCP) can be constructed such that a claim from a honest prover is always accepted and that a verifier is able to detect and reject a false claim from a dishonest prover with probability of at least $1 - 2^{-k}$ (for a suitable security parameter $k$). Additionally, these proofs can be made \emph{non-interactive}, meaning that after an initial setup phase, the publisher and the verifier need to exchange a single message in order to show the validity of the PCP. The most important properties of these PCPs is that they are asymptotically less complex than the original computation: this means that a verifier can check a proof in asymptotically less time than that required to actually perform the computation. A more detailed summary of how PCPs works can be found in \citet{verifying-computations-walfish}, while a more in-depth theoretical explanation of these results can be found in \citet{muggles-goldwasser}.

These theoretical results have already found some very significant practical implementation in the form of SNARKs \cite{snarks}: these proofs are already successfully employed in cryptocurrency environments like ZCash \cite{zerocash}. More related to our specific problem, we found in Pepper \cite{pepper-website} an implementation that allows to perform efficient verifiable computing on arbitrary computations.
Unfortunately, while Pepper is efficient when compared to other implementations that aim at performing generic verifiable computing, it is still far from the performance required by real-world applications: transforming a common computation in a verifiable one entails a computational overhead of at least three order of magnitude, making this technology infeasible.

\subsection{Others}
Verifiable computing would be the actual solution to our problem, but unfortunately it is not usable yet. Thus, we started looking for alternative strategies. One of them \cite{verifying-computation-by-checkpoints} suggests to periodically checkpoint the computation state: these checkpoints can then be used to re-execute the entire computation in parallel, reducing the time needed for the check. However, this techinque is based on basically re-executing the entire computation, which is not desirable in our case. 

Another strategy \cite{integrity-checking-remote-computation} suggests to embed in the computation a piece of software that is able to perform a sort of heartbeat protocol to guarantee that the application is actually running. This idea relies on security by obscurity and we do not see it fit for our purpose.

\citet{verifiable-cloud-computing-for-mobile} describe an interesting application of the idea of garbled circuits and allows to execute a computation in a way that preserves privacy and, as a side effect, is (partially) verifiable. While this would solve most of our problem, the performance and storage costs are again too high.
